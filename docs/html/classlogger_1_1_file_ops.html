<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Logger: logger::FileOps Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Logger<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Logger is a C++ library for logging messages with various severity levels.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classlogger_1_1_file_ops.html','','classlogger_1_1_file_ops-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">logger::FileOps Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for logger::FileOps:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlogger_1_1_file_ops.png" usemap="#logger_3A_3AFileOps_map" alt=""/>
  <map id="logger_3A_3AFileOps_map" name="logger_3A_3AFileOps_map">
<area href="classlogger_1_1_logging_ops.html" alt="logger::LoggingOps" shape="rect" coords="0,0,122,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a03a64d1115c94ee0d130165a9aaf3af6" id="r_a03a64d1115c94ee0d130165a9aaf3af6"><td class="memItemLeft" align="right" valign="top"><a id="a03a64d1115c94ee0d130165a9aaf3af6" name="a03a64d1115c94ee0d130165a9aaf3af6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StdTupple</b> = std::tuple&lt;std::string, std::string, std::string&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f012d226bc15231eafc6e922b9b0ba4" id="r_a1f012d226bc15231eafc6e922b9b0ba4"><td class="memItemLeft" align="right" valign="top"><a id="a1f012d226bc15231eafc6e922b9b0ba4" name="a1f012d226bc15231eafc6e922b9b0ba4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FileOps</b> ()=delete</td></tr>
<tr class="memdesc:a1f012d226bc15231eafc6e922b9b0ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new File Ops object This is a deleted constructor to prevent creating an object of <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> without any parameters. It is not allowed to create a <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> object without specifying the maximum file size. This is to ensure that the file operations are always performed with a valid file size limit. <br /></td></tr>
<tr class="memitem:af1cb2871962b4ba726065b9283a2ba46" id="r_af1cb2871962b4ba726065b9283a2ba46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1cb2871962b4ba726065b9283a2ba46">FileOps</a> (const std::uintmax_t maxFileSize, const std::string_view fileName=&quot;&quot;, const std::string_view filePath=&quot;&quot;, const std::string_view fileExtension=&quot;&quot;)</td></tr>
<tr class="memdesc:af1cb2871962b4ba726065b9283a2ba46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new File Ops object.  <br /></td></tr>
<tr class="memitem:adf167b096f0d175a71884c36c58d7f11" id="r_adf167b096f0d175a71884c36c58d7f11"><td class="memItemLeft" align="right" valign="top"><a id="adf167b096f0d175a71884c36c58d7f11" name="adf167b096f0d175a71884c36c58d7f11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~FileOps</b> ()</td></tr>
<tr class="memdesc:adf167b096f0d175a71884c36c58d7f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the File Ops object Destructor for the <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> class. It will stop the file watcher thread and clear the data records queue. <br /></td></tr>
<tr class="memitem:aef02033ffc14ebba02253364e0f0afd1" id="r_aef02033ffc14ebba02253364e0f0afd1"><td class="memItemLeft" align="right" valign="top"><a id="aef02033ffc14ebba02253364e0f0afd1" name="aef02033ffc14ebba02253364e0f0afd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FileOps</b> (const <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;)=delete</td></tr>
<tr class="memdesc:aef02033ffc14ebba02253364e0f0afd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move constructors and assignment operators are deleted. <br /></td></tr>
<tr class="memitem:acc4334f5646e3a5c8d8d1cd45d7c59fe" id="r_acc4334f5646e3a5c8d8d1cd45d7c59fe"><td class="memItemLeft" align="right" valign="top"><a id="acc4334f5646e3a5c8d8d1cd45d7c59fe" name="acc4334f5646e3a5c8d8d1cd45d7c59fe"></a>
<a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;)=delete</td></tr>
<tr class="memdesc:acc4334f5646e3a5c8d8d1cd45d7c59fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move assignment operators are deleted. <br /></td></tr>
<tr class="memitem:ad5ca9f50abe2d3483478d4a550456965" id="r_ad5ca9f50abe2d3483478d4a550456965"><td class="memItemLeft" align="right" valign="top"><a id="ad5ca9f50abe2d3483478d4a550456965" name="ad5ca9f50abe2d3483478d4a550456965"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FileOps</b> (<a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:ad5ca9f50abe2d3483478d4a550456965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move assignment operators are deleted. <br /></td></tr>
<tr class="memitem:a22eba1838a92393a52521610f266e9e8" id="r_a22eba1838a92393a52521610f266e9e8"><td class="memItemLeft" align="right" valign="top"><a id="a22eba1838a92393a52521610f266e9e8" name="a22eba1838a92393a52521610f266e9e8"></a>
<a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a22eba1838a92393a52521610f266e9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and move assignment operators are deleted. <br /></td></tr>
<tr class="memitem:ac7340a53a75339977ee884aa20209bc4" id="r_ac7340a53a75339977ee884aa20209bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7340a53a75339977ee884aa20209bc4">setFileName</a> (const std::string_view fileName)</td></tr>
<tr class="memdesc:ac7340a53a75339977ee884aa20209bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file name.  <br /></td></tr>
<tr class="memitem:a56b96a1e03ae0eab84e4f78adaa031d8" id="r_a56b96a1e03ae0eab84e4f78adaa031d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56b96a1e03ae0eab84e4f78adaa031d8">setFilePath</a> (const std::string_view filePath)</td></tr>
<tr class="memdesc:a56b96a1e03ae0eab84e4f78adaa031d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file path.  <br /></td></tr>
<tr class="memitem:afe54e4b835129cb16d7f09c58a4a9d74" id="r_afe54e4b835129cb16d7f09c58a4a9d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe54e4b835129cb16d7f09c58a4a9d74">setFileExtension</a> (const std::string_view fileExtension)</td></tr>
<tr class="memdesc:afe54e4b835129cb16d7f09c58a4a9d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the file extension.  <br /></td></tr>
<tr class="memitem:a9b5cd41f91e284aa1423efd294f5c66f" id="r_a9b5cd41f91e284aa1423efd294f5c66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b5cd41f91e284aa1423efd294f5c66f">setMaxFileSize</a> (const std::uintmax_t fileSize)</td></tr>
<tr class="memdesc:a9b5cd41f91e284aa1423efd294f5c66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum file size.  <br /></td></tr>
<tr class="memitem:a7e55ed93d49eacb8b33b605ff251bae9" id="r_a7e55ed93d49eacb8b33b605ff251bae9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e55ed93d49eacb8b33b605ff251bae9">getFileName</a> () const</td></tr>
<tr class="memdesc:a7e55ed93d49eacb8b33b605ff251bae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file name.  <br /></td></tr>
<tr class="memitem:a58793ddb8dd9249820fb27235684761f" id="r_a58793ddb8dd9249820fb27235684761f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58793ddb8dd9249820fb27235684761f">getFilePath</a> () const</td></tr>
<tr class="memdesc:a58793ddb8dd9249820fb27235684761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file path.  <br /></td></tr>
<tr class="memitem:a5e5979b0ef98619f6b8d40dd38268114" id="r_a5e5979b0ef98619f6b8d40dd38268114"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e5979b0ef98619f6b8d40dd38268114">getFileExtension</a> () const</td></tr>
<tr class="memdesc:a5e5979b0ef98619f6b8d40dd38268114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file extension.  <br /></td></tr>
<tr class="memitem:acef98fa5c3a64c29072b8e230ca7c611" id="r_acef98fa5c3a64c29072b8e230ca7c611"><td class="memItemLeft" align="right" valign="top">std::filesystem::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acef98fa5c3a64c29072b8e230ca7c611">getFilePathObj</a> () const</td></tr>
<tr class="memdesc:acef98fa5c3a64c29072b8e230ca7c611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file path object.  <br /></td></tr>
<tr class="memitem:a4b7141a71606382d061b54a611d5d450" id="r_a4b7141a71606382d061b54a611d5d450"><td class="memItemLeft" align="right" valign="top">std::uintmax_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b7141a71606382d061b54a611d5d450">getMaxFileSize</a> () const</td></tr>
<tr class="memdesc:a4b7141a71606382d061b54a611d5d450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum file size.  <br /></td></tr>
<tr class="memitem:af47eefdccf36fdc9001d619e82532f1c" id="r_af47eefdccf36fdc9001d619e82532f1c"><td class="memItemLeft" align="right" valign="top">DataQ&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af47eefdccf36fdc9001d619e82532f1c">getFileContent</a> () const</td></tr>
<tr class="memdesc:af47eefdccf36fdc9001d619e82532f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file content.  <br /></td></tr>
<tr class="memitem:ac4d10e7612d7fd403ff6733a89fbd060" id="r_ac4d10e7612d7fd403ff6733a89fbd060"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4d10e7612d7fd403ff6733a89fbd060">isFilePathEmpty</a> () const</td></tr>
<tr class="memdesc:ac4d10e7612d7fd403ff6733a89fbd060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file path is empty or not.  <br /></td></tr>
<tr class="memitem:a6773f708fca6909f0c2ee085c252e364" id="r_a6773f708fca6909f0c2ee085c252e364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6773f708fca6909f0c2ee085c252e364">fileExists</a> () const</td></tr>
<tr class="memdesc:a6773f708fca6909f0c2ee085c252e364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file exists or not.  <br /></td></tr>
<tr class="memitem:ad06d07e750fb6173901a2a2753d8f760" id="r_ad06d07e750fb6173901a2a2753d8f760"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad06d07e750fb6173901a2a2753d8f760">getClassId</a> () const override</td></tr>
<tr class="memdesc:ad06d07e750fb6173901a2a2753d8f760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Class Id for the object This function is used to get the class id of the object.  <br /></td></tr>
<tr class="memitem:a68fc3f3b24a641328b92f1fec4002c26" id="r_a68fc3f3b24a641328b92f1fec4002c26"><td class="memItemLeft" align="right" valign="top">std::uintmax_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68fc3f3b24a641328b92f1fec4002c26">getFileSize</a> ()</td></tr>
<tr class="memdesc:a68fc3f3b24a641328b92f1fec4002c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the file size.  <br /></td></tr>
<tr class="memitem:a6e1c3f110c9bb8189343d78cacd62001" id="r_a6e1c3f110c9bb8189343d78cacd62001"><td class="memItemLeft" align="right" valign="top"><a id="a6e1c3f110c9bb8189343d78cacd62001" name="a6e1c3f110c9bb8189343d78cacd62001"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> ()</td></tr>
<tr class="memitem:aba03492301b7274d4ca9661b2260622f" id="r_aba03492301b7274d4ca9661b2260622f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba03492301b7274d4ca9661b2260622f">renameFile</a> (const std::string_view newFileName)</td></tr>
<tr class="memdesc:aba03492301b7274d4ca9661b2260622f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename the file. Renames the file with the new name passed to it.  <br /></td></tr>
<tr class="memitem:ae4da78385250d2c4b1a63c1563f2fbda" id="r_ae4da78385250d2c4b1a63c1563f2fbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4da78385250d2c4b1a63c1563f2fbda">readFile</a> ()</td></tr>
<tr class="memdesc:ae4da78385250d2c4b1a63c1563f2fbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the file Reads the file and stores the content in the data records queue. The file is opened in binary and read mode. The file is closed after reading the data.  <br /></td></tr>
<tr class="memitem:a8906ab84fdc28ccc37a7051bfd5de817" id="r_a8906ab84fdc28ccc37a7051bfd5de817"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8906ab84fdc28ccc37a7051bfd5de817">createFile</a> ()</td></tr>
<tr class="memdesc:a8906ab84fdc28ccc37a7051bfd5de817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a File object. Creates a file if it does not exist.  <br /></td></tr>
<tr class="memitem:a7c2d6c85f54a0a3908d6eab20e4d978b" id="r_a7c2d6c85f54a0a3908d6eab20e4d978b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2d6c85f54a0a3908d6eab20e4d978b">deleteFile</a> ()</td></tr>
<tr class="memdesc:a7c2d6c85f54a0a3908d6eab20e4d978b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the file. Deletes the file if it exists.  <br /></td></tr>
<tr class="memitem:a1e535e2c4af474da97c4db88f4fb8742" id="r_a1e535e2c4af474da97c4db88f4fb8742"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e535e2c4af474da97c4db88f4fb8742">clearFile</a> ()</td></tr>
<tr class="memdesc:a1e535e2c4af474da97c4db88f4fb8742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the file. Clears the file contents if it exists.  <br /></td></tr>
<tr class="memitem:ad41560cfe12f3e5943b5f66ec1422495" id="r_ad41560cfe12f3e5943b5f66ec1422495"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::exception_ptr &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#ad41560cfe12f3e5943b5f66ec1422495">getAllExceptions</a> () noexcept</td></tr>
<tr class="memdesc:ad41560cfe12f3e5943b5f66ec1422495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the exceptions happened during the file ops.  <br /></td></tr>
<tr class="memitem:acbac0f934d8475fbd6d1450f099d1e55" id="r_acbac0f934d8475fbd6d1450f099d1e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#acbac0f934d8475fbd6d1450f099d1e55">addRaisedException</a> (const std::exception_ptr &amp;excpPtr) noexcept</td></tr>
<tr class="memdesc:acbac0f934d8475fbd6d1450f099d1e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a raised exception to the exception vector.  <br /></td></tr>
<tr class="memitem:ad1d945e1b1f6aa20e04aade8cf8c1a1d" id="r_ad1d945e1b1f6aa20e04aade8cf8c1a1d"><td class="memItemLeft" align="right" valign="top"><a id="ad1d945e1b1f6aa20e04aade8cf8c1a1d" name="ad1d945e1b1f6aa20e04aade8cf8c1a1d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="memdesc:ad1d945e1b1f6aa20e04aade8cf8c1a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">flush the data records queue. It checks the data records queue and if it is not empty then notifies the watcher thread to write the data to the file/console immediately. <br /></td></tr>
<tr class="memitem:a4f021ea67a3c42591cf67656ea8359bf" id="r_a4f021ea67a3c42591cf67656ea8359bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a4f021ea67a3c42591cf67656ea8359bf">write</a> (const std::string_view data)</td></tr>
<tr class="memdesc:a4f021ea67a3c42591cf67656ea8359bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:ae032bf4987ff9d3dba6cf4971d2fce2c" id="r_ae032bf4987ff9d3dba6cf4971d2fce2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#ae032bf4987ff9d3dba6cf4971d2fce2c">write</a> (const std::vector&lt; std::string_view &gt; &amp;dataVec) noexcept</td></tr>
<tr class="memdesc:ae032bf4987ff9d3dba6cf4971d2fce2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a702f5641afb115265ae77d97d57b22dc" id="r_a702f5641afb115265ae77d97d57b22dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a702f5641afb115265ae77d97d57b22dc">write</a> (const std::list&lt; std::string_view &gt; &amp;dataList) noexcept</td></tr>
<tr class="memdesc:a702f5641afb115265ae77d97d57b22dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a57efb852bcd0d501adeafa7808b1f1fc" id="r_a57efb852bcd0d501adeafa7808b1f1fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a57efb852bcd0d501adeafa7808b1f1fc">write</a> (const std::vector&lt; std::string &gt; &amp;dataVec) noexcept</td></tr>
<tr class="memdesc:a57efb852bcd0d501adeafa7808b1f1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a65fe4ab62f55f8723cc6ecb027e90ec5" id="r_a65fe4ab62f55f8723cc6ecb027e90ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a65fe4ab62f55f8723cc6ecb027e90ec5">write</a> (const std::list&lt; std::string &gt; &amp;dataList) noexcept</td></tr>
<tr class="memdesc:a65fe4ab62f55f8723cc6ecb027e90ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:afdf1b871764378178fabcadc15d13ea7" id="r_afdf1b871764378178fabcadc15d13ea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#afdf1b871764378178fabcadc15d13ea7">write</a> (const uint8_t data)</td></tr>
<tr class="memdesc:afdf1b871764378178fabcadc15d13ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the binary data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a6ff4afaf1dacc0c1de8f11391de7321c" id="r_a6ff4afaf1dacc0c1de8f11391de7321c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a6ff4afaf1dacc0c1de8f11391de7321c">write</a> (const uint16_t data)</td></tr>
<tr class="memdesc:a6ff4afaf1dacc0c1de8f11391de7321c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:aa422fe2844d36bf4be48eee48119e535" id="r_aa422fe2844d36bf4be48eee48119e535"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#aa422fe2844d36bf4be48eee48119e535">write</a> (const uint64_t data)</td></tr>
<tr class="memdesc:aa422fe2844d36bf4be48eee48119e535"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:aa6fb465559a5126231cdc04d5730638a" id="r_aa6fb465559a5126231cdc04d5730638a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#aa6fb465559a5126231cdc04d5730638a">write</a> (const uint32_t data)</td></tr>
<tr class="memdesc:aa6fb465559a5126231cdc04d5730638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:aa7e71cee1829cfd9eeb1c9d6f0fbff71" id="r_aa7e71cee1829cfd9eeb1c9d6f0fbff71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#aa7e71cee1829cfd9eeb1c9d6f0fbff71">write</a> (const std::vector&lt; uint8_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:aa7e71cee1829cfd9eeb1c9d6f0fbff71"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a5dbdb4449d416ea351ea0b9ab128e189" id="r_a5dbdb4449d416ea351ea0b9ab128e189"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a5dbdb4449d416ea351ea0b9ab128e189">write</a> (const std::vector&lt; uint16_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:a5dbdb4449d416ea351ea0b9ab128e189"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a2ff4da15eedd1620ded41571aa13bd46" id="r_a2ff4da15eedd1620ded41571aa13bd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a2ff4da15eedd1620ded41571aa13bd46">write</a> (const std::vector&lt; uint32_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:a2ff4da15eedd1620ded41571aa13bd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:ae08c6edbac905753e2b75976b2ccc74c" id="r_ae08c6edbac905753e2b75976b2ccc74c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#ae08c6edbac905753e2b75976b2ccc74c">write</a> (const std::vector&lt; uint64_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:ae08c6edbac905753e2b75976b2ccc74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up.  <br /></td></tr>
<tr class="memitem:a4bc34840b598f670b677049770db6aba" id="r_a4bc34840b598f670b677049770db6aba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a4bc34840b598f670b677049770db6aba">append</a> (const std::string_view data)</td></tr>
<tr class="memdesc:a4bc34840b598f670b677049770db6aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the data passed to it.  <br /></td></tr>
<tr class="memitem:a0985b3458be1c9a8b3b94bad434c07c0" id="r_a0985b3458be1c9a8b3b94bad434c07c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a0985b3458be1c9a8b3b94bad434c07c0">append</a> (const uint8_t data)</td></tr>
<tr class="memdesc:a0985b3458be1c9a8b3b94bad434c07c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the data passed to it.  <br /></td></tr>
<tr class="memitem:ab795f7144f9b87040c39e6bafbfc2bd2" id="r_ab795f7144f9b87040c39e6bafbfc2bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#ab795f7144f9b87040c39e6bafbfc2bd2">append</a> (const uint16_t data)</td></tr>
<tr class="memdesc:ab795f7144f9b87040c39e6bafbfc2bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the data passed to it.  <br /></td></tr>
<tr class="memitem:af0e2fcb54f066b4989f3468854fbf045" id="r_af0e2fcb54f066b4989f3468854fbf045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#af0e2fcb54f066b4989f3468854fbf045">append</a> (const uint64_t data)</td></tr>
<tr class="memdesc:af0e2fcb54f066b4989f3468854fbf045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the data passed to it.  <br /></td></tr>
<tr class="memitem:aa7047809f2f2aba00796f079100b758a" id="r_aa7047809f2f2aba00796f079100b758a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#aa7047809f2f2aba00796f079100b758a">append</a> (const uint32_t data)</td></tr>
<tr class="memdesc:aa7047809f2f2aba00796f079100b758a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the data passed to it.  <br /></td></tr>
<tr class="memitem:a613f32aae902490bdd65c6d66a658ae1" id="r_a613f32aae902490bdd65c6d66a658ae1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a613f32aae902490bdd65c6d66a658ae1">append</a> (const std::vector&lt; uint8_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:a613f32aae902490bdd65c6d66a658ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the binary data stream passed to it.  <br /></td></tr>
<tr class="memitem:a370795b83a9e59f57ba02e06e3917d59" id="r_a370795b83a9e59f57ba02e06e3917d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a370795b83a9e59f57ba02e06e3917d59">append</a> (const std::vector&lt; uint16_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:a370795b83a9e59f57ba02e06e3917d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the binary data stream passed to it.  <br /></td></tr>
<tr class="memitem:a0d592a94a432d967f2a30ab9f36430e7" id="r_a0d592a94a432d967f2a30ab9f36430e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#a0d592a94a432d967f2a30ab9f36430e7">append</a> (const std::vector&lt; uint32_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:a0d592a94a432d967f2a30ab9f36430e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the binary data stream passed to it.  <br /></td></tr>
<tr class="memitem:af193e61b4e5789148efced1f161839f2" id="r_af193e61b4e5789148efced1f161839f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#af193e61b4e5789148efced1f161839f2">append</a> (const std::vector&lt; uint64_t &gt; &amp;binaryStream)</td></tr>
<tr class="memdesc:af193e61b4e5789148efced1f161839f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the data. Appends the outstream object with the binary data stream passed to it.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2ae2898ef07f2614453dc709e049565c" id="r_a2ae2898ef07f2614453dc709e049565c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae2898ef07f2614453dc709e049565c">isFileEmpty</a> (const std::filesystem::path &amp;file) noexcept</td></tr>
<tr class="memdesc:a2ae2898ef07f2614453dc709e049565c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file is empty or not.  <br /></td></tr>
<tr class="memitem:a6e2437fbb348cb358749b4fed55bd9ac" id="r_a6e2437fbb348cb358749b4fed55bd9ac"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2437fbb348cb358749b4fed55bd9ac">fileExists</a> (const std::filesystem::path &amp;file) noexcept</td></tr>
<tr class="memdesc:a6e2437fbb348cb358749b4fed55bd9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the file does exist at all. Checks if a the file exists at all.  <br /></td></tr>
<tr class="memitem:a7b908f579121d2c1d4e5b7acc3f61add" id="r_a7b908f579121d2c1d4e5b7acc3f61add"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b908f579121d2c1d4e5b7acc3f61add">removeFile</a> (const std::filesystem::path &amp;file) noexcept</td></tr>
<tr class="memdesc:a7b908f579121d2c1d4e5b7acc3f61add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the file if it exists Internally calls fileExists to check if the file exists. If it does, then it removes the file.  <br /></td></tr>
<tr class="memitem:a7a81c361464fe46757c23b07ac86af4a" id="r_a7a81c361464fe46757c23b07ac86af4a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a81c361464fe46757c23b07ac86af4a">clearFile</a> (const std::filesystem::path &amp;file) noexcept</td></tr>
<tr class="memdesc:a7a81c361464fe46757c23b07ac86af4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the file if it exists Internally calls fileExists to check if the file exists. If it does, then it clears the file.  <br /></td></tr>
<tr class="memitem:ad5989004f053283802f2d0ffda189055" id="r_ad5989004f053283802f2d0ffda189055"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5989004f053283802f2d0ffda189055">createFile</a> (const std::filesystem::path &amp;file) noexcept</td></tr>
<tr class="memdesc:ad5989004f053283802f2d0ffda189055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file if it does not exist Internally calls fileExists to check if the file exists. If it does not, then it creates the file.  <br /></td></tr>
<tr class="memitem:ac63e44e5b1e172f1c5a76d0475323111" id="r_ac63e44e5b1e172f1c5a76d0475323111"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac63e44e5b1e172f1c5a76d0475323111">readFileByteRange</a> (<a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;file, const std::streampos start, const std::streampos end, std::vector&lt; char &gt; &amp;outBuff)</td></tr>
<tr class="memdesc:ac63e44e5b1e172f1c5a76d0475323111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range of bytes from the file.  <br /></td></tr>
<tr class="memitem:a9cbc5c930b531e306dd2046661edf88f" id="r_a9cbc5c930b531e306dd2046661edf88f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbc5c930b531e306dd2046661edf88f">readFileLineRange</a> (<a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;file, const size_t startLineNo, const size_t endLineNo, std::vector&lt; std::string &gt; &amp;outBuf)</td></tr>
<tr class="memdesc:a9cbc5c930b531e306dd2046661edf88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a range of lines from the file Reads a range of lines from the file specified by the <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> object. The range is specified by the start and end line numbers.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8bb11e03b0b08eac82faddfaabbff483" id="r_a8bb11e03b0b08eac82faddfaabbff483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bb11e03b0b08eac82faddfaabbff483">writeToOutStreamObject</a> (BufferQ &amp;&amp;dataQueue, std::exception_ptr &amp;excpPtr) override</td></tr>
<tr class="memdesc:a8bb11e03b0b08eac82faddfaabbff483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to the out stream object.  <br /></td></tr>
<tr class="memitem:a04fd0d77ff8a135a77a4ee1cebfbd840" id="r_a04fd0d77ff8a135a77a4ee1cebfbd840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04fd0d77ff8a135a77a4ee1cebfbd840">writeDataTo</a> (const std::string_view data) override</td></tr>
<tr class="memdesc:a04fd0d77ff8a135a77a4ee1cebfbd840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the out stream object.  <br /></td></tr>
<tr class="memitem:afba9d3e1e49aa61ac234d9c24f0ab296" id="r_afba9d3e1e49aa61ac234d9c24f0ab296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#afba9d3e1e49aa61ac234d9c24f0ab296">keepWatchAndPull</a> ()</td></tr>
<tr class="memdesc:afba9d3e1e49aa61ac234d9c24f0ab296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep watch and pull the data from the data records queue.  <br /></td></tr>
<tr class="memitem:abce0236d18de61b82ca3ae3d37e4effc" id="r_abce0236d18de61b82ca3ae3d37e4effc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#abce0236d18de61b82ca3ae3d37e4effc">pop</a> (BufferQ &amp;data)</td></tr>
<tr class="memdesc:abce0236d18de61b82ca3ae3d37e4effc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the data to a data buffer.  <br /></td></tr>
<tr class="memitem:ac4b41603b60e34e37853f07aa06793b9" id="r_ac4b41603b60e34e37853f07aa06793b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlogger_1_1_logging_ops.html#ac4b41603b60e34e37853f07aa06793b9">push</a> (const std::string_view data)</td></tr>
<tr class="memdesc:ac4b41603b60e34e37853f07aa06793b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push the data to the data records queue.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a45fd54c0ae14141b9cb42a970d10c39c" id="r_a45fd54c0ae14141b9cb42a970d10c39c"><td class="memItemLeft" align="right" valign="top"><a id="a45fd54c0ae14141b9cb42a970d10c39c" name="a45fd54c0ae14141b9cb42a970d10c39c"></a>
BufferQ&#160;</td><td class="memItemRight" valign="bottom"><b>m_DataRecords</b></td></tr>
<tr class="memitem:aa05b8bc4f8057c30484c5a923decba73" id="r_aa05b8bc4f8057c30484c5a923decba73"><td class="memItemLeft" align="right" valign="top"><a id="aa05b8bc4f8057c30484c5a923decba73" name="aa05b8bc4f8057c30484c5a923decba73"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>m_DataRecordsMtx</b></td></tr>
<tr class="memitem:a36a155d54d37360a253aea7f775c7388" id="r_a36a155d54d37360a253aea7f775c7388"><td class="memItemLeft" align="right" valign="top"><a id="a36a155d54d37360a253aea7f775c7388" name="a36a155d54d37360a253aea7f775c7388"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>m_DataRecordsCv</b></td></tr>
<tr class="memitem:ac512380ed73bffaec28194e74aee09cc" id="r_ac512380ed73bffaec28194e74aee09cc"><td class="memItemLeft" align="right" valign="top"><a id="ac512380ed73bffaec28194e74aee09cc" name="ac512380ed73bffaec28194e74aee09cc"></a>
std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_dataReady</b></td></tr>
<tr class="memitem:a233d7834db9dd507b6a6b4ceb3d8f98f" id="r_a233d7834db9dd507b6a6b4ceb3d8f98f"><td class="memItemLeft" align="right" valign="top"><a id="a233d7834db9dd507b6a6b4ceb3d8f98f" name="a233d7834db9dd507b6a6b4ceb3d8f98f"></a>
std::atomic_bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_shutAndExit</b></td></tr>
<tr class="memitem:aedbc4b62915c7161a7513ef6b92cfcaf" id="r_aedbc4b62915c7161a7513ef6b92cfcaf"><td class="memItemLeft" align="right" valign="top"><a id="aedbc4b62915c7161a7513ef6b92cfcaf" name="aedbc4b62915c7161a7513ef6b92cfcaf"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><b>m_watcher</b></td></tr>
<tr class="memitem:a6d053376574b6bc5f4e0325f44c450a4" id="r_a6d053376574b6bc5f4e0325f44c450a4"><td class="memItemLeft" align="right" valign="top"><a id="a6d053376574b6bc5f4e0325f44c450a4" name="a6d053376574b6bc5f4e0325f44c450a4"></a>
std::vector&lt; std::exception_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_excpPtrVec</b></td></tr>
<tr class="memdesc:a6d053376574b6bc5f4e0325f44c450a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is a vector of exception pointers which is used to store the exceptions occurred during the data operations. <br /></td></tr>
</table>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1cb2871962b4ba726065b9283a2ba46" name="af1cb2871962b4ba726065b9283a2ba46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cb2871962b4ba726065b9283a2ba46">&#9670;&#160;</a></span>FileOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FileOps::FileOps </td>
          <td>(</td>
          <td class="paramtype">const std::uintmax_t</td>          <td class="paramname"><span class="paramname"><em>maxFileSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>fileExtension</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new File Ops object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxFileSize</td><td>Maximum size of the file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Name of the file (default blank) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>Path where file would be placed eventually (default current path) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtension</td><td>Extension of the file like .txt or .log etc. (default .txt) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The max file size should be greater than the max line length allowed, which is 4096 bytes or 4KB, defined as bufferSize to prevent truncation if you are writing single line length to its full capacity. </dd></dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="acbac0f934d8475fbd6d1450f099d1e55" name="acbac0f934d8475fbd6d1450f099d1e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbac0f934d8475fbd6d1450f099d1e55">&#9670;&#160;</a></span>addRaisedException()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void logger::LoggingOps::addRaisedException </td>
          <td>(</td>
          <td class="paramtype">const std::exception_ptr &amp;</td>          <td class="paramname"><span class="paramname"><em>excpPtr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a raised exception to the exception vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">excpPtr</td><td>The exception pointer to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex to ensure that only one thread can add an exception at a time. </dd></dl>

</div>
</div>
<a id="a4bc34840b598f670b677049770db6aba" name="a4bc34840b598f670b677049770db6aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc34840b598f670b677049770db6aba">&#9670;&#160;</a></span>append() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the data passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be appended to the outstream object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#a4f021ea67a3c42591cf67656ea8359bf" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const std::string_view data)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#a4f021ea67a3c42591cf67656ea8359bf" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const std::string_view data)</a> </dd></dl>

</div>
</div>
<a id="a370795b83a9e59f57ba02e06e3917d59" name="a370795b83a9e59f57ba02e06e3917d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370795b83a9e59f57ba02e06e3917d59">&#9670;&#160;</a></span>append() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the binary data stream passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint16_t) to be appended to the outstream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#a5dbdb4449d416ea351ea0b9ab128e189" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint16_t&gt;&amp; binaryStream)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#a5dbdb4449d416ea351ea0b9ab128e189" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint16_t&gt;&amp; binaryStream)</a> </dd></dl>

</div>
</div>
<a id="a0d592a94a432d967f2a30ab9f36430e7" name="a0d592a94a432d967f2a30ab9f36430e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d592a94a432d967f2a30ab9f36430e7">&#9670;&#160;</a></span>append() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the binary data stream passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint32_t) to be appended to the outstream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#a2ff4da15eedd1620ded41571aa13bd46" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint32_t&gt;&amp; binaryStream)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#a2ff4da15eedd1620ded41571aa13bd46" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint32_t&gt;&amp; binaryStream)</a> </dd></dl>

</div>
</div>
<a id="af193e61b4e5789148efced1f161839f2" name="af193e61b4e5789148efced1f161839f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af193e61b4e5789148efced1f161839f2">&#9670;&#160;</a></span>append() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the binary data stream passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint64_t) to be appended to the outstream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#ae08c6edbac905753e2b75976b2ccc74c" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint64_t&gt;&amp; binaryStream)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#ae08c6edbac905753e2b75976b2ccc74c" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint64_t&gt;&amp; binaryStream)</a> </dd></dl>

</div>
</div>
<a id="a613f32aae902490bdd65c6d66a658ae1" name="a613f32aae902490bdd65c6d66a658ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613f32aae902490bdd65c6d66a658ae1">&#9670;&#160;</a></span>append() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the binary data stream passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint8_t) to be appended to the outstream object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#aa7e71cee1829cfd9eeb1c9d6f0fbff71" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint8_t&gt;&amp; binaryStream)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#aa7e71cee1829cfd9eeb1c9d6f0fbff71" title="write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to...">write(const std::vector&lt;uint8_t&gt;&amp; binaryStream)</a> </dd></dl>

</div>
</div>
<a id="ab795f7144f9b87040c39e6bafbfc2bd2" name="ab795f7144f9b87040c39e6bafbfc2bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab795f7144f9b87040c39e6bafbfc2bd2">&#9670;&#160;</a></span>append() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const uint16_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the data passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be appended to the outstream object. Is of type uint16_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#a6ff4afaf1dacc0c1de8f11391de7321c" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint16_t data)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#a6ff4afaf1dacc0c1de8f11391de7321c" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint16_t data)</a> </dd></dl>

</div>
</div>
<a id="aa7047809f2f2aba00796f079100b758a" name="aa7047809f2f2aba00796f079100b758a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7047809f2f2aba00796f079100b758a">&#9670;&#160;</a></span>append() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the data passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be appended to the outstream object. Is of type uint32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#aa6fb465559a5126231cdc04d5730638a" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint32_t data)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#aa6fb465559a5126231cdc04d5730638a" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint32_t data)</a> </dd></dl>

</div>
</div>
<a id="af0e2fcb54f066b4989f3468854fbf045" name="af0e2fcb54f066b4989f3468854fbf045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e2fcb54f066b4989f3468854fbf045">&#9670;&#160;</a></span>append() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the data passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be appended to the outstream object. Is of type uint64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#aa422fe2844d36bf4be48eee48119e535" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint64_t data)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#aa422fe2844d36bf4be48eee48119e535" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint64_t data)</a> </dd></dl>

</div>
</div>
<a id="a0985b3458be1c9a8b3b94bad434c07c0" name="a0985b3458be1c9a8b3b94bad434c07c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0985b3458be1c9a8b3b94bad434c07c0">&#9670;&#160;</a></span>append() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::append </td>
          <td>(</td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append the data. Appends the outstream object with the data passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be appended to the outstream object. Is of type uint8_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#afdf1b871764378178fabcadc15d13ea7" title="write the data. Writes the binary data passed to it. The data is pushed to the data records queue and...">write(const uint8_t data)</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#afdf1b871764378178fabcadc15d13ea7" title="write the data. Writes the binary data passed to it. The data is pushed to the data records queue and...">write(const uint8_t data)</a> </dd></dl>

</div>
</div>
<a id="a1e535e2c4af474da97c4db88f4fb8742" name="a1e535e2c4af474da97c4db88f4fb8742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e535e2c4af474da97c4db88f4fb8742">&#9670;&#160;</a></span>clearFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::clearFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the file. Clears the file contents if it exists. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the file was cleared successfully, otherwise </dd>
<dd>
false</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex and condition variable to ensure that only one thread can clear the file at a time. </dd></dl>

</div>
</div>
<a id="a7a81c361464fe46757c23b07ac86af4a" name="a7a81c361464fe46757c23b07ac86af4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a81c361464fe46757c23b07ac86af4a">&#9670;&#160;</a></span>clearFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::clearFile </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the file if it exists Internally calls fileExists to check if the file exists. If it does, then it clears the file. </p>
<dl class="section note"><dt>Note</dt><dd>Throws no exception </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the file was cleared successfully, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a8906ab84fdc28ccc37a7051bfd5de817" name="a8906ab84fdc28ccc37a7051bfd5de817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8906ab84fdc28ccc37a7051bfd5de817">&#9670;&#160;</a></span>createFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::createFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a File object. Creates a file if it does not exist. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the file was created successfully, otherwise </dd>
<dd>
false</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex and condition variable to ensure that only one thread can create the file at a time. </dd></dl>

</div>
</div>
<a id="ad5989004f053283802f2d0ffda189055" name="ad5989004f053283802f2d0ffda189055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5989004f053283802f2d0ffda189055">&#9670;&#160;</a></span>createFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::createFile </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a file if it does not exist Internally calls fileExists to check if the file exists. If it does not, then it creates the file. </p>
<dl class="section note"><dt>Note</dt><dd>Throws no exception </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the file was created successfully, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a7c2d6c85f54a0a3908d6eab20e4d978b" name="a7c2d6c85f54a0a3908d6eab20e4d978b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2d6c85f54a0a3908d6eab20e4d978b">&#9670;&#160;</a></span>deleteFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::deleteFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the file. Deletes the file if it exists. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the file was deleted successfully, otherwise </dd>
<dd>
false</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex and condition variable to ensure that only one thread can delete the file at a time. </dd></dl>

</div>
</div>
<a id="a6773f708fca6909f0c2ee085c252e364" name="a6773f708fca6909f0c2ee085c252e364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6773f708fca6909f0c2ee085c252e364">&#9670;&#160;</a></span>fileExists() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool logger::FileOps::fileExists </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the file exists or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the file exists, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a6e2437fbb348cb358749b4fed55bd9ac" name="a6e2437fbb348cb358749b4fed55bd9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2437fbb348cb358749b4fed55bd9ac">&#9670;&#160;</a></span>fileExists() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::fileExists </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the file does exist at all. Checks if a the file exists at all. </p>
<dl class="section note"><dt>Note</dt><dd>Throws no exception </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be checked for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the file does exist, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ad41560cfe12f3e5943b5f66ec1422495" name="ad41560cfe12f3e5943b5f66ec1422495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41560cfe12f3e5943b5f66ec1422495">&#9670;&#160;</a></span>getAllExceptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::exception_ptr &gt; &amp; logger::LoggingOps::getAllExceptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the exceptions happened during the file ops. </p>
<dl class="section return"><dt>Returns</dt><dd>std::filesystem::path The file path object </dd></dl>

</div>
</div>
<a id="ad06d07e750fb6173901a2a2753d8f760" name="ad06d07e750fb6173901a2a2753d8f760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06d07e750fb6173901a2a2753d8f760">&#9670;&#160;</a></span>getClassId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string logger::FileOps::getClassId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Class Id for the object This function is used to get the class id of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string The class id of the object </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is used to identify the class of the object in the polymorphic hierarchy. It is used to identify the class of the object at runtime. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>LoggingOps::getClassId() </dd>
<dd>
LoggingOps::getClassId() for more details </dd></dl>

<p>Implements <a class="el" href="classlogger_1_1_logging_ops.html">logger::LoggingOps</a>.</p>

</div>
</div>
<a id="af47eefdccf36fdc9001d619e82532f1c" name="af47eefdccf36fdc9001d619e82532f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47eefdccf36fdc9001d619e82532f1c">&#9670;&#160;</a></span>getFileContent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataQ logger::FileOps::getFileContent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file content. </p>
<dl class="section return"><dt>Returns</dt><dd>DataQ The file content which is a queue of shared pointers to strings. The strings are the lines of the file. The queue is thread safe and can be accessed by multiple threads at the same time. </dd></dl>

</div>
</div>
<a id="a5e5979b0ef98619f6b8d40dd38268114" name="a5e5979b0ef98619f6b8d40dd38268114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5979b0ef98619f6b8d40dd38268114">&#9670;&#160;</a></span>getFileExtension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string logger::FileOps::getFileExtension </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file extension. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string The file extension </dd></dl>

</div>
</div>
<a id="a7e55ed93d49eacb8b33b605ff251bae9" name="a7e55ed93d49eacb8b33b605ff251bae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e55ed93d49eacb8b33b605ff251bae9">&#9670;&#160;</a></span>getFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string logger::FileOps::getFileName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file name. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string The file name </dd></dl>

</div>
</div>
<a id="a58793ddb8dd9249820fb27235684761f" name="a58793ddb8dd9249820fb27235684761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58793ddb8dd9249820fb27235684761f">&#9670;&#160;</a></span>getFilePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string logger::FileOps::getFilePath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file path. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string The file path </dd></dl>

</div>
</div>
<a id="acef98fa5c3a64c29072b8e230ca7c611" name="acef98fa5c3a64c29072b8e230ca7c611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef98fa5c3a64c29072b8e230ca7c611">&#9670;&#160;</a></span>getFilePathObj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::filesystem::path logger::FileOps::getFilePathObj </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the file path object. </p>
<dl class="section return"><dt>Returns</dt><dd>std::filesystem::path The file path object </dd></dl>

</div>
</div>
<a id="a68fc3f3b24a641328b92f1fec4002c26" name="a68fc3f3b24a641328b92f1fec4002c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fc3f3b24a641328b92f1fec4002c26">&#9670;&#160;</a></span>getFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uintmax_t FileOps::getFileSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the file size. </p>
<dl class="section return"><dt>Returns</dt><dd>std::uintmax_t The file size </dd></dl>

</div>
</div>
<a id="a4b7141a71606382d061b54a611d5d450" name="a4b7141a71606382d061b54a611d5d450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7141a71606382d061b54a611d5d450">&#9670;&#160;</a></span>getMaxFileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uintmax_t logger::FileOps::getMaxFileSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum file size. </p>
<dl class="section return"><dt>Returns</dt><dd>std::uintmax_t The maximum file size </dd></dl>

</div>
</div>
<a id="a2ae2898ef07f2614453dc709e049565c" name="a2ae2898ef07f2614453dc709e049565c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae2898ef07f2614453dc709e049565c">&#9670;&#160;</a></span>isFileEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::isFileEmpty </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the file is empty or not. </p>
<p>Checks if a file specified by the input file path object, is empty or not. The function is static to the class and not thread safe.</p>
<dl class="section note"><dt>Note</dt><dd>Throws no exception </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be checked for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the file contains some data </dd>
<dd>
false otherwise. Also if the file is non existing (internally calls fileExists) then it also returns false.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6e2437fbb348cb358749b4fed55bd9ac" title="Check if the file does exist at all. Checks if a the file exists at all.">fileExists</a> </dd></dl>

</div>
</div>
<a id="ac4d10e7612d7fd403ff6733a89fbd060" name="ac4d10e7612d7fd403ff6733a89fbd060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d10e7612d7fd403ff6733a89fbd060">&#9670;&#160;</a></span>isFilePathEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool logger::FileOps::isFilePathEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the file path is empty or not. </p>
<dl class="section return"><dt>Returns</dt><dd>true If the file path is empty, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="afba9d3e1e49aa61ac234d9c24f0ab296" name="afba9d3e1e49aa61ac234d9c24f0ab296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba9d3e1e49aa61ac234d9c24f0ab296">&#9670;&#160;</a></span>keepWatchAndPull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::keepWatchAndPull </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keep watch and pull the data from the data records queue. </p>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex and condition variable to ensure that only one thread can keep watch and pull the data at a time.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>writeToFile </dd>
<dd>
<a class="el" href="classlogger_1_1_logging_ops.html#abce0236d18de61b82ca3ae3d37e4effc" title="Pops the data to a data buffer.">pop</a> </dd>
<dd>
<a class="el" href="classlogger_1_1_logging_ops.html#ac4b41603b60e34e37853f07aa06793b9" title="Push the data to the data records queue.">push</a> </dd></dl>

</div>
</div>
<a id="abce0236d18de61b82ca3ae3d37e4effc" name="abce0236d18de61b82ca3ae3d37e4effc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce0236d18de61b82ca3ae3d37e4effc">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LoggingOps::pop </td>
          <td>(</td>
          <td class="paramtype">BufferQ &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops the data to a data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The data to be popped from the data records queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the data was popped successfully, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="ac4b41603b60e34e37853f07aa06793b9" name="ac4b41603b60e34e37853f07aa06793b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b41603b60e34e37853f07aa06793b9">&#9670;&#160;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::push </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push the data to the data records queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be pushed to the data records queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex and condition variable to ensure that only one thread can push the data at a time. </dd></dl>

</div>
</div>
<a id="ae4da78385250d2c4b1a63c1563f2fbda" name="ae4da78385250d2c4b1a63c1563f2fbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da78385250d2c4b1a63c1563f2fbda">&#9670;&#160;</a></span>readFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FileOps::readFile </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the file Reads the file and stores the content in the data records queue. The file is opened in binary and read mode. The file is closed after reading the data. </p>
<dl class="section note"><dt>Note</dt><dd>Before reading it makes sure if there is any data in the data records queue which is yet to be processed. If there is, then it signals the file watcher thread to process the data first before reading the file. Thread safe.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#afba9d3e1e49aa61ac234d9c24f0ab296" title="Keep watch and pull the data from the data records queue.">keepWatchAndPull</a> </dd>
<dd>
writeToFile </dd>
<dd>
<a class="el" href="classlogger_1_1_logging_ops.html#abce0236d18de61b82ca3ae3d37e4effc" title="Pops the data to a data buffer.">pop</a> </dd>
<dd>
<a class="el" href="classlogger_1_1_logging_ops.html#ac4b41603b60e34e37853f07aa06793b9" title="Push the data to the data records queue.">push</a> </dd></dl>

</div>
</div>
<a id="ac63e44e5b1e172f1c5a76d0475323111" name="ac63e44e5b1e172f1c5a76d0475323111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63e44e5b1e172f1c5a76d0475323111">&#9670;&#160;</a></span>readFileByteRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::readFileByteRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streampos</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::streampos</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outBuff</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range of bytes from the file. </p>
<p>Reads a range of bytes from the file specified by the <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> object. The range is specified by the start and end positions.</p>
<dl class="section note"><dt>Note</dt><dd>Throws exceptions which is collected in the static std::vector&lt;std::exception_ptr&gt; m_excpPtrVec and can be accessed using <a class="el" href="classlogger_1_1_logging_ops.html#ad41560cfe12f3e5943b5f66ec1422495" title="Get all the exceptions happened during the file ops.">getAllExceptions()</a> function. </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start position of the range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end position of the range </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuff</td><td>The output buffer to store the read bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the read was successful, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a9cbc5c930b531e306dd2046661edf88f" name="a9cbc5c930b531e306dd2046661edf88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbc5c930b531e306dd2046661edf88f">&#9670;&#160;</a></span>readFileLineRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::readFileLineRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>startLineNo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>endLineNo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>outBuf</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a range of lines from the file Reads a range of lines from the file specified by the <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> object. The range is specified by the start and end line numbers. </p>
<dl class="section note"><dt>Note</dt><dd>Throws exceptions which is collected in the static std::vector&lt;std::exception_ptr&gt; m_excpPtrVec and can be accessed using <a class="el" href="classlogger_1_1_logging_ops.html#ad41560cfe12f3e5943b5f66ec1422495" title="Get all the exceptions happened during the file ops.">getAllExceptions()</a> function. </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The <a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startLineNo</td><td>The starting line number (1-based index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endLineNo</td><td>The ending line number (1-based index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The line numbers are inclusive, meaning both startLineNo and endLineNo are included in the range. </dd>
<dd>
If startLineNo is greater than endLineNo, the function will return false and will throw an exception. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outBuf</td><td>The output buffer to store the read lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The outBuf will be cleared before reading the lines. If no lines are read, it will remain empty. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true If the read was successful and lines were read, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a7b908f579121d2c1d4e5b7acc3f61add" name="a7b908f579121d2c1d4e5b7acc3f61add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b908f579121d2c1d4e5b7acc3f61add">&#9670;&#160;</a></span>removeFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::removeFile </td>
          <td>(</td>
          <td class="paramtype">const std::filesystem::path &amp;</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the file if it exists Internally calls fileExists to check if the file exists. If it does, then it removes the file. </p>
<dl class="section note"><dt>Note</dt><dd>Throws no exception </dd>
<dd>
This function is not thread safe. The caller must ensure thread safety.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The file to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the file was removed successfully, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="aba03492301b7274d4ca9661b2260622f" name="aba03492301b7274d4ca9661b2260622f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba03492301b7274d4ca9661b2260622f">&#9670;&#160;</a></span>renameFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FileOps::renameFile </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>newFileName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename the file. Renames the file with the new name passed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newFileName</td><td>The new name of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the file was renamed successfully, otherwise </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="afe54e4b835129cb16d7f09c58a4a9d74" name="afe54e4b835129cb16d7f09c58a4a9d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe54e4b835129cb16d7f09c58a4a9d74">&#9670;&#160;</a></span>setFileExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp; FileOps::setFileExtension </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>fileExtension</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtension</td><td>Extension of the file like .txt or .log etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a>&amp; Refrence to the current object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls populateFilePathObj to adjust full path of the file (if required) </dd></dl>

</div>
</div>
<a id="ac7340a53a75339977ee884aa20209bc4" name="ac7340a53a75339977ee884aa20209bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7340a53a75339977ee884aa20209bc4">&#9670;&#160;</a></span>setFileName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp; FileOps::setFileName </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileName</td><td>Name of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a>&amp; Refrence to the current object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls populateFilePathObj to adjust full path of the file (if required) </dd></dl>

</div>
</div>
<a id="a56b96a1e03ae0eab84e4f78adaa031d8" name="a56b96a1e03ae0eab84e4f78adaa031d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b96a1e03ae0eab84e4f78adaa031d8">&#9670;&#160;</a></span>setFilePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp; FileOps::setFilePath </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>filePath</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>Path where file would be placed eventually </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a>&amp; Refrence to the current object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls populateFilePathObj to adjust full path of the file (if required) </dd></dl>

</div>
</div>
<a id="a9b5cd41f91e284aa1423efd294f5c66f" name="a9b5cd41f91e284aa1423efd294f5c66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b5cd41f91e284aa1423efd294f5c66f">&#9670;&#160;</a></span>setMaxFileSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a> &amp; logger::FileOps::setMaxFileSize </td>
          <td>(</td>
          <td class="paramtype">const std::uintmax_t</td>          <td class="paramname"><span class="paramname"><em>fileSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum file size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSize</td><td>Maximum size of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The max file size should be greater than the max line length allowed, which is 4096 bytes or 4KB, defined as bufferSize to prevent truncation if you are writing single line length to its full capacity. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classlogger_1_1_file_ops.html">FileOps</a>&amp; Refrence to the current object </dd></dl>

</div>
</div>
<a id="a65fe4ab62f55f8723cc6ecb027e90ec5" name="a65fe4ab62f55f8723cc6ecb027e90ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fe4ab62f55f8723cc6ecb027e90ec5">&#9670;&#160;</a></span>write() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dataList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataList</td><td>The data in a list to be written to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a702f5641afb115265ae77d97d57b22dc" name="a702f5641afb115265ae77d97d57b22dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702f5641afb115265ae77d97d57b22dc">&#9670;&#160;</a></span>write() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::list&lt; std::string_view &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dataList</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataList</td><td>The data in a list to be written to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f021ea67a3c42591cf67656ea8359bf" name="a4f021ea67a3c42591cf67656ea8359bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f021ea67a3c42591cf67656ea8359bf">&#9670;&#160;</a></span>write() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57efb852bcd0d501adeafa7808b1f1fc" name="a57efb852bcd0d501adeafa7808b1f1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57efb852bcd0d501adeafa7808b1f1fc">&#9670;&#160;</a></span>write() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dataVec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataVec</td><td>The data in a vector to be written to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae032bf4987ff9d3dba6cf4971d2fce2c" name="ae032bf4987ff9d3dba6cf4971d2fce2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae032bf4987ff9d3dba6cf4971d2fce2c">&#9670;&#160;</a></span>write() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string_view &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dataVec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataVec</td><td>The data in a vector to be written to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dbdb4449d416ea351ea0b9ab128e189" name="a5dbdb4449d416ea351ea0b9ab128e189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbdb4449d416ea351ea0b9ab128e189">&#9670;&#160;</a></span>write() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint16_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint16_t) to be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#a6ff4afaf1dacc0c1de8f11391de7321c" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint16_t data)</a> in a loop </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#a6ff4afaf1dacc0c1de8f11391de7321c" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint16_t data)</a> </dd></dl>

</div>
</div>
<a id="a2ff4da15eedd1620ded41571aa13bd46" name="a2ff4da15eedd1620ded41571aa13bd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff4da15eedd1620ded41571aa13bd46">&#9670;&#160;</a></span>write() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint32_t) to be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#aa6fb465559a5126231cdc04d5730638a" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint32_t data)</a> in a loop </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#aa6fb465559a5126231cdc04d5730638a" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint32_t data)</a> </dd></dl>

</div>
</div>
<a id="ae08c6edbac905753e2b75976b2ccc74c" name="ae08c6edbac905753e2b75976b2ccc74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08c6edbac905753e2b75976b2ccc74c">&#9670;&#160;</a></span>write() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint64_t) to be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#aa422fe2844d36bf4be48eee48119e535" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint64_t data)</a> in a loop </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#aa422fe2844d36bf4be48eee48119e535" title="write the data. Writes the data passed to it. The data is pushed to the data records queue and then t...">write(const uint64_t data)</a> </dd></dl>

</div>
</div>
<a id="aa7e71cee1829cfd9eeb1c9d6f0fbff71" name="aa7e71cee1829cfd9eeb1c9d6f0fbff71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e71cee1829cfd9eeb1c9d6f0fbff71">&#9670;&#160;</a></span>write() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binaryStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the out stream with the binary data stream passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryStream</td><td>The binary data stream (uint8_t) to be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It internally calls <a class="el" href="classlogger_1_1_logging_ops.html#afdf1b871764378178fabcadc15d13ea7" title="write the data. Writes the binary data passed to it. The data is pushed to the data records queue and...">write(const uint8_t data)</a> in a loop </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlogger_1_1_logging_ops.html#afdf1b871764378178fabcadc15d13ea7" title="write the data. Writes the binary data passed to it. The data is pushed to the data records queue and...">write(const uint8_t data)</a> </dd></dl>

</div>
</div>
<a id="a6ff4afaf1dacc0c1de8f11391de7321c" name="a6ff4afaf1dacc0c1de8f11391de7321c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff4afaf1dacc0c1de8f11391de7321c">&#9670;&#160;</a></span>write() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const uint16_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written to the out stream. Is of type uint16_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data is converted to a string of 16 bits and then written to the out stream. </dd></dl>

</div>
</div>
<a id="aa6fb465559a5126231cdc04d5730638a" name="aa6fb465559a5126231cdc04d5730638a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fb465559a5126231cdc04d5730638a">&#9670;&#160;</a></span>write() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written to the outstream. Is of type uint32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data is converted to a string of 32 bits and then written to. </dd></dl>

</div>
</div>
<a id="aa422fe2844d36bf4be48eee48119e535" name="aa422fe2844d36bf4be48eee48119e535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa422fe2844d36bf4be48eee48119e535">&#9670;&#160;</a></span>write() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the data passed to it. The data is pushed to the data records queue and then the watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written to the outstream. Is of type uint64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data is converted to a string of 64 bits and then written to. </dd></dl>

</div>
</div>
<a id="afdf1b871764378178fabcadc15d13ea7" name="afdf1b871764378178fabcadc15d13ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf1b871764378178fabcadc15d13ea7">&#9670;&#160;</a></span>write() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LoggingOps::write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inherited">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write the data. Writes the binary data passed to it. The data is pushed to the data records queue and then the file watcher thread will pick it up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written to. Is of type uint8_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04fd0d77ff8a135a77a4ee1cebfbd840" name="a04fd0d77ff8a135a77a4ee1cebfbd840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fd0d77ff8a135a77a4ee1cebfbd840">&#9670;&#160;</a></span>writeDataTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FileOps::writeDataTo </td>
          <td>(</td>
          <td class="paramtype">const std::string_view</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to the out stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data to be written to the out stream object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is pure virtual and must be implemented by the derived classes. It is used to write the data to the out stream object. </dd></dl>
<p>First check if the current log file size and the data size to be written exceeds the max file size limit set by the user. If so then rename the existing file with the current time stamp and create a new blank file for further logging/writting. Throw exception for any runtime error case.</p>

<p>Implements <a class="el" href="classlogger_1_1_logging_ops.html#af4f15c575d0891f4c1124b89fc48e16e">logger::LoggingOps</a>.</p>

</div>
</div>
<a id="a8bb11e03b0b08eac82faddfaabbff483" name="a8bb11e03b0b08eac82faddfaabbff483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb11e03b0b08eac82faddfaabbff483">&#9670;&#160;</a></span>writeToOutStreamObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FileOps::writeToOutStreamObject </td>
          <td>(</td>
          <td class="paramtype">BufferQ &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>dataQueue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::exception_ptr &amp;</td>          <td class="paramname"><span class="paramname"><em>excpPtr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to the out stream object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dataQueue</td><td>The data queue to be written to the out stream object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">excpPtr</td><td>The exception pointer to be used for exception handling</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe. It uses mutex and condition variable to ensure that only one thread can write to the outstream object at a time. </dd></dl>

<p>Reimplemented from <a class="el" href="classlogger_1_1_logging_ops.html#aa2b1fbef0bd58bcadbf5d40e67085369">logger::LoggingOps</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_file_ops_8hpp_source.html">FileOps.hpp</a></li>
<li>src/<b>FileOps.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>logger</b></li><li class="navelem"><a href="classlogger_1_1_file_ops.html">FileOps</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
